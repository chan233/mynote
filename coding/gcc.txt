对于库文件未找到,因为编译、链接都没有问题,那就是运行链接动态库时找不到动态库了。
对于运行链接动态库时找不到动态库的方法,有四种方法排除解决.

方法1.
找到缺少的动态库(由于编译和链接时候的使用到了这个动态库，所以很容易找得到),
将其加到/lib,/usr/lib中的一个文件夹下,这几个文件夹是系统默认的搜索路径。将库文件放置在其中，运行时就可以搜索到了。

方法2.
设置临时增加链接动态库的路径;使用
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:your_lib_path

方法3.
/etc/ld.so.cache中缓存了动态库路径，可以通过修改配置文件/etc/ld.so.conf中指定的动态库搜索路径，然后执行ldconfig命令来改变。

方法4.
在链接时语句后面添加如下命令:

-Wl,-rpath= my_thirdparty_lib_path

-Wl,-rpath= my_thirdparty_lib_path 是为程序添加一个运行时库文件搜索路径的命令,
在使用gcc编译链接时添加即可。

-Wl
  这个是gcc的参数，表示编译器将后面的参数传递给链接器ld。

-rpath
rpath是gcc的一个参数。rpath添加一个目录。当程序被加载时,优先搜寻此目录,寻找动态库


1. 添加一个文件夹作为运行时库的搜索路径。在将ELF可执行文件与共享对象链接时使用此选项;
2. 在链接时，一些动态库明确的链接了其他动态库， 则-rpath选项也可用于定位这些链接的动态库;
3. 在运行链接时，会优先搜索-rpath的路径，再去搜索LD_RUN_PATH的路径。

四种方法的优先顺序：四->二->三->一

链接器
https://blog.csdn.net/seek_0380/article/details/82189938
链接器是为了将目标文件和库文件链接在一块 以生成可执行文件
可执行文件区别与普通文件在于地址空间的使用,在主流操作系统中,
可执行文件都是基于虚拟地址空间的,既每个可执行文件都有相同且独立的地址空间,且各个段结构相似
而普通文件的地址空间都是从零开始的

编译过程
https://blog.csdn.net/woshinia/article/details/11060797
gcc and g++分别是gnu的c & c++编译器 gcc/g++在执行编译工作的时候，总共需要4步

1.预处理,生成.i的文件[预处理器cpp]

2.将预处理后的文件转换成汇编语言,生成文件.s[编译器egcs]

3.由汇编变为目标代码(机器代码)生成.o的文件[汇编器as]

4.连接目标代码,生成可执行程序[链接器ld]

生成动态库就加编译选项 -shared -fPIC 将生成.so

生成静态库是使用 ar 命令将编译成的.o打包成.a

gcc一些常用选项

动态库所在目录
-L

 链接到动态库
-l -lssl(=-libssl) 
设置寻找头文件的目录 XXX第一个寻找头文件的目录，寻找的顺序是：XXX-->/usr/include-->/usr/local/include

-I XXX 

-Wl, rpath=
