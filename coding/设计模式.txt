--------------------------------
设计模式
--------------------------------
在稳定和变化之间,寻找隔离点.然后来分离他们,从而来管理变化
好的面向对象设计,是指那些可以满足应对变化,提高复用的设计
抵御变化:变化是复用的天敌

分解

抽象

责任

--------------------------------
第二讲

遵循8大设计原则:原则比模式重要
--------------------------------

1.依赖倒置原则 DIP
高层模块不应该依赖于低层模块,二者都应该依赖的与抽象,抽象层应该是稳定的
抽象作为中间层,在给高层调用时保持稳定.
当需求变更时,通过变化低层实现,从而不影响到高层.

2.开放封闭原则 OCP
通过增加模块来应对变化,而不是砍掉全部重做
通过扩展方式来应对变化，而不是更改源代码来应对变化
3.单一职责原则 SRP
保持类的功能单一性,不要什么事都做,每个类各司其职

4.liskov替换原则 LSP
子类必须能够替换他们的基类 (IS-A) ,若子类继承到父类的方法修改太多,不通用,那就不应该属于这个父类

5.接口隔离原则 ISP
接口应该小而完备,不必要的方法就不要 public

6.优先使用对象组合,而不是类继承

7.封装变化点

8.针对接口编程,而不是针对实现编程
通过接口方式解决问题,而不是给客户具体的实现,不依赖与具体的类型来解决问题
实现高内聚,松耦合

重构的关键技法:
静态→动态 
早绑定→晚绑定
继承→组合
编译时依赖→运行时依赖
紧耦合→松耦合

--------------------------------
第三讲

模板方法 template method(组件协作)
--------------------------------
在稳定的结构中,应对子步骤的变化

把结构框架(程序流程)定义在父类,需要变化的方法写成虚函数或纯虚函数,交给子类去重写实现,从而不改变框架的结构

通过子类的多态性,创建父类的指针或引用,来调用子类虚函数.

把需要变化的方法声明为 protected

--------------------------------
第四讲

策略模式 Strategy （组件协作）
--------------------------------

定义一系列算法,封装每个算法,并使他们可以互换,动态的改变对象的行为

策略模式可以让算法独立于使用它的客户端,

如果出现大量的 if else, 就可以考虑用策略模式

if else 属于结构化程序设计的分而治之行为,区别与面向对象程序设计
--------------------------------
第五讲

观察者模式 Observer （组件协作）
--------------------------------
定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。

主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者
